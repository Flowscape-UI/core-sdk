# Руководство по тестированию функционала копирования и группировки

## Проблема

При копировании/вырезании/вставке и группировке нод их размеры могут откатываться к значениям по умолчанию. Это происходит из-за:

1. **Конструкторы нод используют значения по умолчанию** (`width: 100, height: 100`)
2. **При десериализации** атрибуты могут не применяться в правильном порядке
3. **При группировке** трансформации могут теряться

## Решение через Unit-тесты

Создана комплексная система тестов, которая автоматически выявляет подобные баги.

## Установка и запуск

### 1. Установите зависимости

```bash
npm install
```

Это установит:

- `vitest` - современный тест-раннер
- `@vitest/ui` - UI-интерфейс для тестов
- `@vitest/coverage-v8` - покрытие кода
- `jsdom` - эмуляция браузерного окружения

### 2. Запустите тесты

```bash
# Watch-режим (автоматический перезапуск при изменениях)
npm test

# Один прогон
npm run test:run

# С UI-интерфейсом (откроется в браузере)
npm run test:ui

# С покрытием кода
npm run test:coverage
```

## Что покрывают тесты

### ✅ Копирование/Вставка (`copy-paste-sizes.test.ts`)

**Одиночные ноды:**

- Сохранение базовых размеров (width/height)
- Сохранение трансформаций (scaleX/scaleY/rotation)
- Сохранение визуального размера (width × scaleX)

**Группы:**

- Сохранение размеров нод в группе
- Сохранение трансформаций группы
- Сохранение визуальных размеров в трансформированной группе

**Вырезание:**

- Сохранение всех атрибутов после Cut → Paste

### ✅ Группировка/Разгруппировка (`grouping-sizes.test.ts`)

**Создание группы:**

- Размеры нод не изменяются при добавлении в группу
- Трансформации нод сохраняются
- Визуальный размер остаётся прежним

**Трансформация группы:**

- Визуальный размер нод изменяется пропорционально
- Неравномерная трансформация работает корректно

**Разгруппировка:**

- Визуальный размер сохраняется
- Трансформации правильно композируются (нода + группа)

**Временная группа (Shift+Click):**

- Размеры сохраняются при коммите в постоянную группу (Ctrl+G)

**Сложные сценарии:**

- Группировка → Трансформация → Разгруппировка → Копирование

## Как тесты помогают выявлять баги

### Пример 1: Потеря размеров при вставке

**Без тестов:**

- Баг проявляется только визуально
- Нужно вручную проверять каждый сценарий
- Легко пропустить edge-cases

**С тестами:**

```typescript
it('должна сохранять размеры при копировании/вставке', () => {
  const node = core.nodes.addShape({ width: 200, height: 150 });
  const originalWidth = node.getNode().width();

  const clipboard = simulateCopy(node);
  const pastedNode = simulatePaste(clipboard);

  expect(pastedNode.getNode().width()).toBe(originalWidth); // ❌ FAIL: 100 !== 200
});
```

Тест **сразу показывает**, что размер откатился к 100 (значение по умолчанию).

### Пример 2: Потеря трансформаций при группировке

**Без тестов:**

- Баг может проявиться только при конкретной последовательности действий
- Сложно воспроизвести

**С тестами:**

```typescript
it('должна сохранять трансформации при коммите временной группы', () => {
  // Создаём временную группу
  const tempGroup = createTempGroup([node1, node2]);
  tempGroup.scaleX(2); // Растягиваем в 2 раза

  const beforeWidth = node1.getNode().getClientRect().width;

  // Коммитим в постоянную группу
  const permanentGroup = commitTempGroup(tempGroup);

  const afterWidth = node1.getNode().getClientRect().width;

  expect(afterWidth).toBeCloseTo(beforeWidth, 1); // ❌ FAIL: размер изменился
});
```

### Пример 3: Композиция трансформаций

**Без тестов:**

- Сложно вычислить ожидаемый результат вручную
- Баг может быть незаметен визуально

**С тестами:**

```typescript
it('должна правильно композировать трансформации', () => {
  node.scaleX(1.5); // Нода растянута в 1.5 раза
  group.scaleX(2); // Группа растянута в 2 раза

  // После разгруппировки ожидаем: 1.5 × 2 = 3
  ungroup(group);

  expect(node.getNode().scaleX()).toBeCloseTo(3, 2); // ✅ PASS
});
```

## Преимущества автоматического тестирования

### 1. **Раннее обнаружение багов**

Тесты запускаются при каждом изменении кода и сразу показывают, что сломалось.

### 2. **Регрессионное тестирование**

Если баг был исправлен, тест гарантирует, что он не вернётся в будущем.

### 3. **Документация поведения**

Тесты служат живой документацией того, как должна работать система.

### 4. **Уверенность при рефакторинге**

Можно смело менять код, зная, что тесты поймают ошибки.

### 5. **Покрытие edge-cases**

Тесты проверяют сложные сценарии, которые легко пропустить при ручном тестировании.

## Интеграция в CI/CD

Добавьте в `.github/workflows/ci.yml`:

```yaml
- name: Run tests
  run: npm run test:run

- name: Check coverage
  run: npm run test:coverage
```

Тесты будут запускаться автоматически при каждом push/PR.

## Как добавлять новые тесты

Когда находите новый баг:

1. **Напишите тест, который воспроизводит баг** (тест должен падать)
2. **Исправьте баг**
3. **Убедитесь, что тест проходит**
4. **Закоммитьте и тест, и исправление**

Пример:

```typescript
// 1. Воспроизводим баг (тест падает)
it('должна сохранять offsetX/offsetY при вставке', () => {
  const node = core.nodes.addShape({ width: 100, height: 100 });
  node.getNode().offsetX(50);
  node.getNode().offsetY(50);

  const clipboard = simulateCopy(node);
  const pastedNode = simulatePaste(clipboard);

  expect(pastedNode.getNode().offsetX()).toBe(50); // ❌ FAIL
  expect(pastedNode.getNode().offsetY()).toBe(50); // ❌ FAIL
});

// 2. Исправляем код в NodeHotkeysPlugin
// 3. Тест проходит ✅
// 4. Коммитим
```

## Метрики покрытия

После `npm run test:coverage` откройте `coverage/index.html`:

- **Statements:** % покрытых строк кода
- **Branches:** % покрытых условных веток (if/else)
- **Functions:** % покрытых функций
- **Lines:** % покрытых строк

**Цель:** минимум 80% покрытия для критичного функционала (копирование, группировка).

## Заключение

Unit-тесты - это **инвестиция в качество кода**:

- ✅ Автоматически выявляют баги
- ✅ Предотвращают регрессии
- ✅ Ускоряют разработку (не нужно вручную тестировать каждый раз)
- ✅ Повышают уверенность в коде
- ✅ Служат документацией

**Запускайте тесты регулярно** и добавляйте новые при обнаружении багов!
